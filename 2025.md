# Java Annotations - Interview Preparation Notes

## üìå Quick Overview
**Annotations** = Metadata + Code that provides information about the program without affecting execution.

## üéØ Most Important Annotations for Interviews

### 1. Built-in Annotations (Must Know)

```java
// 1. @Override - Compiler checks if method actually overrides
@Override
public String toString() { return "Custom String"; }

// 2. @Deprecated - Marks method as obsolete
@Deprecated
public void oldMethod() { }

// 3. @SuppressWarnings - Suppresses compiler warnings
@SuppressWarnings("unchecked")
List list = new ArrayList();

// 4. @FunctionalInterface - For lambda expressions
@FunctionalInterface
interface Calculator { int calculate(int x, int y); }
```

### 2. Meta-Annotations (Create Custom Annotations)

```java
// Essential meta-annotations:
@Target(ElementType.METHOD)    // Where annotation can be applied
@Retention(RetentionPolicy.RUNTIME) // How long annotation is kept
public @interface MyAnnotation { }
```

**RetentionPolicy Options:**
- `SOURCE` - Discarded during compilation (e.g., `@Override`)
- `CLASS` - In bytecode but not at runtime (default)
- `RUNTIME` - Available at runtime (most common for frameworks)

**ElementType Options:**
- `TYPE` - Class, interface
- `METHOD` - Methods
- `FIELD` - Fields
- `PARAMETER` - Parameters

## üî• Common Interview Questions & Answers

### Q1: What are annotations in Java?
**Answer:** Annotations are metadata that provide data about a program but don't affect the code execution. They start with `@` symbol.

### Q2: Difference between annotation and comment?
**Answer:**
- **Comments:** For humans, ignored by compiler
- **Annotations:** For compiler/tools, can be processed at compile-time or runtime

### Q3: Name some built-in annotations
**Answer:**
- `@Override`, `@Deprecated`, `@SuppressWarnings`
- `@SafeVarargs`, `@FunctionalInterface`

### Q4: How to create custom annotations?
**Answer:**
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface TestCase {
    int id();
    String description() default "No description";
}
```

### Q5: How to process annotations at runtime?
**Answer:** Using Reflection API
```java
// Check if annotation is present
if(method.isAnnotationPresent(TestCase.class)) {
    TestCase testCase = method.getAnnotation(TestCase.class);
    System.out.println("Test ID: " + testCase.id());
}
```

## üí° Real-world Examples (Framework Usage)

### Spring Framework Annotations
```java
@Component
public class UserService {
    
    @Autowired
    private UserRepository repository;
    
    @RequestMapping("/users")
    public List<User> getUsers() {
        return repository.findAll();
    }
}
```

### JUnit Testing Annotations
```java
public class TestClass {
    
    @BeforeEach
    public void setup() { }
    
    @Test
    @DisplayName("Should create user")
    public void testCreateUser() { }
    
    @AfterEach
    public void cleanup() { }
}
```

## üõ†Ô∏è Practical Coding Examples

### Example 1: Custom Validation Annotation
```java
// Define annotation
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface NotNull {
    String message() default "Field cannot be null";
}

// Usage
public class User {
    @NotNull(message = "Username is required")
    private String username;
}

// Processor
public class Validator {
    public static void validate(Object obj) throws Exception {
        for(Field field : obj.getClass().getDeclaredFields()) {
            if(field.isAnnotationPresent(NotNull.class)) {
                field.setAccessible(true);
                if(field.get(obj) == null) {
                    NotNull annotation = field.getAnnotation(NotNull.class);
                    throw new ValidationException(annotation.message());
                }
            }
        }
    }
}
```

### Example 2: Simple Dependency Injection
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Inject { }

public class Container {
    public static void injectDependencies(Object target) {
        for(Field field : target.getClass().getDeclaredFields()) {
            if(field.isAnnotationPresent(Inject.class)) {
                // Create and inject dependency
                Object dependency = createInstance(field.getType());
                field.setAccessible(true);
                field.set(target, dependency);
            }
        }
    }
}
```

## üìã Key Points to Remember

1. **Annotations don't directly affect program semantics**
2. **Processed by:** Compiler, build tools, or runtime environment
3. **Common uses:** Configuration, code generation, documentation
4. **Reflection API** is used to read annotations at runtime
5. **Meta-annotations** annotate other annotations

## ‚ùì Frequently Asked Interview Questions

1. **What is the purpose of @Override annotation?**
   - Ensures method actually overrides a superclass method
   - Provides compile-time safety

2. **What is @Deprecated used for?**
   - Marks code that should no longer be used
   - Compiler generates warning when used

3. **How does @SuppressWarnings work?**
   - Suppresses specific compiler warnings
   - Common values: "unchecked", "deprecation"

4. **What is the difference between @Target and @Retention?**
   - **@Target:** Where annotation can be applied (method, class, field)
   - **@Retention:** How long annotation is retained (source, class, runtime)

5. **Can annotations have methods?**
   - Yes, but they're called "elements" and have restrictions
   - Can only return primitives, String, Class, enum, annotations, or arrays

## üéØ Quick Revision Checklist

- [ ] Understand built-in annotations
- [ ] Know how to create custom annotations
- [ ] Understand meta-annotations (@Target, @Retention)
- [ ] Know how to process annotations using reflection
- [ ] Remember real-world use cases (Spring, JUnit)
- [ ] Practice coding examples

## üí™ Pro Tips for Interview

1. **Always mention practical uses** (Spring, Hibernate, JUnit)
2. **Explain retention policies** clearly
3. **Show how reflection is used** to process annotations
4. **Compare with similar concepts** (XML configuration vs annotations)
5. **Be ready to write code** for custom annotations

**Remember:** Annotations make code more declarative and reduce boilerplate code!
